<!DOCTYPE html>
<!-- 
  閃ｰセンｰ (SEN)
  Version: 1.1.2 (更新日: 2026-01-19)
  Author: TK Lab. (https://x.com/TK_Lab_)
  Description: 表示された一文字を打つだけのタイピングゲーム。
  License: このコードは個人利用・改変・再配布自由ですが、商用利用はご遠慮ください。
           クレジット表記を削除しないでください。
  Credits:
    - Mersenne Twister実装: 公開ドメインの標準実装を参考・改変
    - Font: Google Fonts (JetBrains Mono, Noto Sans JP)
  注意: PC物理キーボードでのプレイを推奨。モバイル・仮想キーボードでは動作保証外。

  ChangeLog:
    - 2026-01-16 (v1.0.0)
      ・初版公開
    - 2026-01-17 (v1.0.1)
      ・ゲーム開始時のカウントダウン（3→2→1）後、最初の出題文字が「1」の場合にわかりにくい問題を修正
      ・ハイフン（-）とアンダースコア（_）の視認性が低い問題を改善
      ・一部のブラウザでプレイ中に「/」キーを押した際にブラウザの検索窓（クイック検索）が開いてしまうなどの問題を修正
      ・一部のブラウザでレイアウトが崩れる問題を修正
    - 2026-01-18 (v1.1.0)
      ・ランキングシステムを実装
    - 2026-01-18 (v1.1.1)
      ・一部の評価メッセージを変更
    - 2026-01-19 (v1.1.2)
      ・ランキング登録のダイアログを、記録が更新されたときだけ出すように変更
-->
<html lang="ja">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>閃ｰセンｰ</title>
   <style>
      * {
         font-family: "JetBrains Mono", "Noto Sans JP", sans-serif !important;
      }
      body {
         display: flex;
         flex-direction: column;
         align-items: center;
         justify-content: flex-start;
         min-height: 100vh;
         margin: 0;
         padding-top: 20px;
         padding-bottom: 20px;
         background-color: #f0f0f0;
         user-select: none;
         box-sizing: border-box;
      }
      h1 {
         margin: 0 0 20px 0;
         font-size: 36px;
      }
      #mode-stats-container {
         position: relative;
         width: 100%;
         max-width: 900px;
         min-height: 80px;
         margin: 0;
         display: flex;
         flex-direction: column;
         justify-content: center;
         align-items: center;
      }
      #mode-select {
         display: flex;
         justify-content: center;
         gap: 30px;
         margin: 0;
      }
      .mode-group {
         position: relative;
         height: 60px;
         display: flex;
         flex-direction: column;
         justify-content: center;
         padding: 12px;
         border-radius: 8px;
         background: #fff;
         min-width: 160px;
         text-align: center;
         border: 3px solid transparent;
         box-sizing: border-box;
         cursor: pointer;
         box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }
      .mode-group:not(.focused):hover {
         background: #e8f5e9;
         box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
      }
      .mode-group.focused {
         border-color: #00DD00;
         box-shadow: 0 6px 16px rgba(0, 0, 0, 0.25);
         cursor: default;
      }
      .mode-group.focused:hover {
         background: #fff;
         box-shadow: 0 6px 16px rgba(0, 0, 0, 0.25);
         border-bottom-right-radius: 0;
      }
      .selected-item {
         font-size: 1.8em;
         font-weight: bold;
         height: 60px;
         display: flex;
         align-items: center;
         justify-content: center;
      }
      .dropdown {
         position: absolute;
         top: 100%;
         left: auto;
         right: -3px;
         width: calc(100% * 46 / 56 + 3px);
         background: #fff;
         border: 3px solid #00DD00;
         border-top: none;
         border-radius: 0 0 8px 8px;
         box-shadow: 0 8px 16px rgba(0,0,0,0.2);
         display: none;
         flex-direction: column;
         z-index: 10;
         padding: 0 12px;
         box-sizing: border-box;
      }
      .mode-group.focused:hover .dropdown {
         display: flex;
      }
      .dropdown-item {
         padding: 12px 0;
         cursor: pointer;
         text-align: center;
         font-size: 1.4em;
      }
      .dropdown-item:hover {
         background: #e8f5e9;
      }
      body.result-mode .mode-group {
         cursor: default !important;
      }
      body.result-mode .mode-group:hover {
         background: #fff !important;
         box-shadow: none !important;
      }
      body.result-mode .mode-group.focused:hover {
         background: #fff !important;
         box-shadow: 0 4px 12px rgba(0,0,0,0.2) !important;
      }
      body.result-mode .mode-group.focused:hover .dropdown {
         display: none !important;
      }
      body.result-mode .mode-group {
         box-shadow: none !important;
      }
      #stats {
         display: none;
         font-size: 24px;
         justify-content: center;
         gap: 20px;
         width: 500px;
         margin: 0 auto;
      }
      .stat-item {
         flex: 0 0 auto;
         display: flex;
         flex-direction: row;
         align-items: center;
         justify-content: center;
         gap: 8px;
         text-align: center;
      }
      .stat-label {
         font-weight: bold;
         white-space: nowrap;
         flex-shrink: 0;
      }
      .stat-number {
         font-weight: bold;
         min-width: 60px;
         text-align: center;
         flex-shrink: 0;
      }
      #target {
         font-size: 160px;
         font-weight: bold;
         height: 180px;
         width: 180px;
         margin: 20px 0 10px 0;
         color: #333;
         text-align: center;
         display: flex;
         align-items: center;
         justify-content: center;
         line-height: 180px;
         box-sizing: border-box;
      }
      #message {
         font-size: 36px;
         height: 60px;
         line-height: 60px;
         margin: 0 0 30px 0;
         font-weight: bold;
         text-align: center;
      }
      #ui-guide {
         font-size: 24px;
         color: #666;
         margin-bottom: 20px;
         min-height: 30px;
         text-align: center;
      }
      #timer {
         font-size: 48px;
         font-weight: bold;
         color: #d35400;
         margin: 10px 0;
      }
      #result {
         margin-top: 0;
         text-align: center;
         max-width: 90%;
         display: none;
      }
      #result-content > div {
         margin: 8px 0;
      }
      #detail-container {
         width: fit-content;
         max-width: 100%;
         background: #fff;
         border: 1px solid #ccc;
         border-radius: 6px;
         padding: 0px;
         margin-top: 20px;
         margin: 20px auto;
         display: block;
         overflow-x: hidden;
         box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
         box-sizing: border-box;
      }
      #detail-graph {
         display: block;
         max-width: none;
         width: 100%;
         overflow-x: auto;
         overflow-y: hidden;
         margin: 0;
         padding-top: 20px;
         padding-bottom: 0px;
         box-sizing: border-box;
      }
      #graph-canvas {
         display: block;
         margin: 0 auto;
       }

      #detail-table-container {
         display: none;
      }
      #detail-table {
         width: fit-content;
         border-collapse: collapse;
         font-size: 18px;
         margin: 0 auto;
      }
      #detail-table th, #detail-table td {
         padding: 8px 12px;
         text-align: left;
         border-bottom: 1px solid #ddd;
         white-space: nowrap;
      }
      #detail-table th {
         background-color: #f2f2f2;
         font-weight: bold;
      }
      #detail-table th:nth-child(1), #detail-table td:nth-child(1) { text-align: right; }
      #detail-table th:nth-child(2), #detail-table td:nth-child(2) { text-align: center; }
      #detail-table th:nth-child(3), #detail-table td:nth-child(3) { text-align: center; }
      #detail-table th:nth-child(4), #detail-table td:nth-child(4) { text-align: center; }
      #detail-table th:nth-child(5), #detail-table td:nth-child(5) { text-align: right; }
      #detail-stats table {
         width: fit-content;
         border-collapse: collapse;
         font-size: 18px;
         margin: 20px auto;
      }
      #detail-stats th, #detail-stats td {
         padding: 10px 20px;
         text-align: left;
         border-bottom: 1px solid #ddd;
      }
      #detail-stats th {
         background-color: #f2f2f2;
         font-weight: bold;
         text-align: center;
         padding-right: 30px;
      }
      #detail-stats .rank-row td:nth-child(2) {
         text-align: right;
         padding-right: 20px;
      }
      #detail-stats td {
         text-align: center;
      }
      .stats-table-wrapper {
         margin: 30px auto;
         text-align: center;
      }
      .stats-table-wrapper table {
         width: fit-content;
         margin: 0 auto;
         border-collapse: collapse;
         font-size: 18px;
      }
      .stats-table-wrapper th,
      .stats-table-wrapper td {
         padding: 10px 20px;
         text-align: center;
         border-bottom: 1px solid #ddd;
      }
      .stats-table-wrapper th {
         background-color: #f2f2f2;
         font-weight: bold;
      }
      #rank-table th {
         width: 130px !important;
         min-width: 130px !important;
         padding: 2px 30px !important;
         text-align: center !important;
      }
      #rank-table td {
         width: 70px !important;
         min-width: 70px !important;
         padding: 2px 60px !important;
         text-align: right !important;
      }
      #rank-table {
         width: fit-content !important;
         table-layout: fixed !important;
      }
      .stats-table-wrapper:first-of-type table th {
         width: 130px !important;
         min-width: 130px !important;
         padding: 2px 30px !important;
         text-align: left !important;
      }
      .stats-table-wrapper:first-of-type table td {
         width: 130px !important;
         min-width: 130px !important;
         padding: 2px 30px !important;
         text-align: right !important;
      }
      .stats-table-wrapper:first-of-type table {
         width: fit-content !important;
         table-layout: fixed !important;
      }
      .stats-table-wrapper:last-of-type table th:nth-child(1),
      .stats-table-wrapper:last-of-type table td:nth-child(1) {
         width: 80px !important;
         min-width: 80px !important;
         padding: 2px 0px !important;
         text-align: center !important;
      }
      .stats-table-wrapper:last-of-type table th:nth-child(2),
      .stats-table-wrapper:last-of-type table td:nth-child(2) {
         width: 120px !important;
         min-width: 120px !important;
         padding: 2px 0px !important;
         text-align: right !important;
      }
      .stats-table-wrapper:last-of-type table th:nth-child(3),
      .stats-table-wrapper:last-of-type table td:nth-child(3) {
         width: 100px !important;
         min-width: 100px !important;
         padding: 2px 40px !important;
         text-align: right !important;
      }
      .stats-table-wrapper:last-of-type table {
         width: fit-content !important;
         table-layout: fixed !important;
      }
      .stats-table-wrapper > div:first-child {
         margin-top: 20px !important;
         margin-bottom: 20px !important;
      }
      .flex-time {
         display: flex !important;
         justify-content: flex-end !important;
         align-items: center !important;
         gap: 8px !important;
         padding: 0 20px !important;
      }
      .time-char {
         width: 60px !important;
         text-align: center !important;
         white-space: nowrap !important;
      }
      .time-arrow {
         flex-shrink: 0 !important;
      }
      .time-main {
         text-align: right !important;
         flex-shrink: 0 !important;
      }
      .keyboard-guide {
         width: auto;
         background: #fff;
         padding: 8px;
         border-radius: 6px;
         box-shadow: 0 4px 12px rgba(0,0,0,0.2);
         border: 1px solid #ccc;
         font-size: 20px;
         line-height: 1.6;
         color: #333;
         text-align: center;
         margin: 20px 0;
         display: flex;
         flex-direction: column;
         gap: 4px;
      }
      .row {
         display: flex;
         width: auto;
         margin: 0 auto;
         gap: 4px;
         justify-content: center;
         padding: 0;
      }
      .key {
         box-sizing: border-box;
         display: inline-flex;
         flex-direction: column;
         align-items: center;
         justify-content: center;
         width: 36px;
         height: 36px;
         margin: 0;
         background: #f0f0f0;
         border: 1px solid #ccc;
         border-radius: 6px;
         box-shadow: 0 2px 4px rgba(0,0,0,0.1);
         font-weight: bold;
         font-size: 12px;
         color: #333;
         text-align: center;
         line-height: 1.0;
         gap: 4px;
      }
      .key.hidden {
         color: #f0f0f0;
      }
      .key[data-type="function"] {
         background: #e0e0e0;
         color: #333;
      }
      .key.tab { width: 56px; }
      .key.backspace { width: 76px; }
      .key.caps { width: 66px; }
      .key.enter { width: 86px; }
      .key.left-shift { width: 86px; }
      .key.right-shift { width: 106px; }
      .key.backslash { width: 56px; }
      .key.ctrl { width: 46px; }
      .key.win { width: 46px; }
      .key.alt { width: 46px; }
      .key.fn { width: 46px; }
      .key.app { width: 46px; }
      .key.space { width: 246px; background: #e0e0e0; }
      #jis-keyboard-guide .key.space { width: 176px; }
      #jis-keyboard-guide .key.muhenkan { width: 36px; }
      #jis-keyboard-guide .key.henkan { width: 46px; }
      #jis-keyboard-guide .key.katakana { width: 46px; }
      #jis-keyboard-guide .key.enter { width: 46px; }
      #jis-keyboard-guide .key.right-shift { width: 66px; }
      #jis-keyboard-guide .key.win { width: 36px; }
      #jis-keyboard-guide .key.app { width: 36px; }
      #jis-keyboard-guide .key.upper-enter {
         width: 56px !important;
      }
      #jis-keyboard-guide .key.lower-enter {
         width: 46px !important;
      }
      #jis-keyboard-guide .key.lower-enter {
         border-radius: 6px !important;
         position: relative;
      }
      #jis-keyboard-guide .key.upper-enter {
         border-bottom-right-radius: 0 !important;
         border-bottom: 1px solid #ccc;
      }
      #jis-keyboard-guide .row:nth-child(3) .key.lower-enter {
         height: 41px !important;
         border-top-right-radius: 0 !important;
         border-top-left-radius: 0 !important;
         border-top: none #ccc;
         margin-top: -5px;
         box-shadow: 0 4px 4px rgba(0,0,0,0.1) !important;
      }
      .key .shift-symbol,
      .key .base-symbol {
         font-size: 11px;
         margin: 0;
         line-height: 1;
         display: block;
         text-align: center;
      }
      .key.katakana .shift-symbol,
      .key.katakana .base-symbol {
         font-size: 9px;
         margin: 0;
         line-height: 1;
         display: block;
         text-align: center;
      }
      .correct-key {
         color: white !important;
      }
      .miss-key {
         color: white !important;
      }
      .hint-key {
         color: white !important;
      }
      .key[data-type="function"].correct-key {
         color: white !important;
      }
      .key[data-type="function"].miss-key {
         color: white !important;
      }
      .key[data-type="function"].hint-key {
         color: white !important;
      }

      .key.partial-correct {
         border: 4px solid #00BB00 !important;
         box-shadow: 0 4px 4px rgba(0,0,0,0.1) !important;
      }
      #detail-toggle {
         display: flex;
         justify-content: center;
         gap: 20px;
         margin: 20px 0 10px 0;
      }
      .toggle-btn {
         padding: 10px 20px;
         font-size: 16px;
         font-weight: bold;
         border: none !important;
         outline: none !important;
         border-radius: 8px;
         cursor: pointer;
         background: #ccc;
         color: #333;
         box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      }
      .toggle-btn:hover {
         background: #e8f5e9;
         color: #333;
      }
      .toggle-btn:focus {
         outline: none !important;
      }
      .toggle-btn.active {
         background: #fff;
         color: #333;
         box-shadow: none;
         cursor: default;
      }
      .toggle-btn.active:hover {
         background: #fff;
      }

      #ranking-content h2 { font-size: 32px; margin-bottom: 20px; }
      /* メインコンテンツの下マージンをゼロに（隙間なくフッターに接続） */
      #jis-keyboard-guide,
      #us-keyboard-guide,
      #detail-container {
         margin-bottom: 0 !important;
      }

      /* フッターをコンテナ影の上に重ね（背景透明） */
      footer {
         margin-top: -60px;  /* 負の値でコンテナの上に重ね（影がかぶる量を調整、-20px~-60pxで試してください） */
         padding-top: 60px;  /* 重ね分を補正して文字位置を下に */
         padding-bottom: 40px;
         background: transparent;  /* 背景透明！影が透ける */
         width: fit-content;
         margin-left: auto;
         margin-right: auto;
         pointer-events: none;  /* 影部分をクリック可能に（文字部分は後で修正） */
      }

      /* フッター内部コンテンツ（クリック可能 + 文字読みやすく） */
      footer > div {
         width: fit-content;
         min-width: 596px;  /* あなたのいい感じの596px固定 */
         max-width: 596px;
         margin-left: auto;
         margin-right: auto;
         text-align: center;
         background: rgba(240, 240, 240, 0);
         padding: 10px 20px;
         border-radius: 8px;
         pointer-events: auto;  /* 文字部分だけクリック可能 */
         color: #333;  /* 文字色を濃く（影の上でも見やすく） */
      }

      footer .policy-content {
         text-align: left;
         width: 100%;
         max-width: 596px;
         margin-left: auto;
         margin-right: auto;
         transition: all 0.3s ease;
         word-wrap: break-word;
         background: transparent;  /* 本文背景透明（薄い背景はタイトルだけでもOK） */
      }

      /* モバイル対応 */
      @media (max-width: 768px) {
         footer {
            margin-top: -20px;
            padding-top: 40px;
         }
         footer > div {
            min-width: auto;
            max-width: 100%;
            padding: 10px;
         }
      }
   </style>
   <link rel="preconnect" href="https://fonts.googleapis.com">
   <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
   <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
   <h1>閃ｰセンｰ</h1>
   <div id="ui-guide">Enter/Space：開始</div>
   <div id="mode-stats-container">
      <div id="mode-select">
         <div class="mode-group focused" id="time-group">
            <div class="selected-item">30秒</div>
            <div class="dropdown">
               <div class="dropdown-item" data-value="15秒">15秒</div>
               <div class="dropdown-item" data-value="30秒">30秒</div>
               <div class="dropdown-item" data-value="60秒">60秒</div>
            </div>
         </div>
         <div class="mode-group" id="difficulty-group">
            <div class="selected-item">Normal</div>
            <div class="dropdown">
               <div class="dropdown-item" data-value="Easy">Easy</div>
               <div class="dropdown-item" data-value="Normal">Normal</div>
               <div class="dropdown-item" data-value="Hard">Hard</div>
            </div>
         </div>
         <div class="mode-group" id="layout-group">
            <div class="selected-item">JIS</div>
            <div class="dropdown">
               <div class="dropdown-item" data-value="JIS">JIS</div>
               <div class="dropdown-item" data-value="US">US</div>
            </div>
         </div>
      </div>
      <div id="stats">
         <div class="stat-item">
            <span class="stat-label">正解:</span>
            <span id="correct" class="stat-number">0</span>
         </div>
         <div class="stat-item">
            <span class="stat-label">ミス:</span>
            <span id="miss" class="stat-number">0</span>
         </div>
         <div class="stat-item">
            <span class="stat-label">スコア:</span>
            <span id="score" class="stat-number">0</span>
         </div>
      </div>
   </div>
   <div id="timer">60</div>
   <div id="target">閃</div>
   <div id="message">ｰセンｰ</div>

   <div id="jis-keyboard-guide" class="keyboard-guide" style="display: none;">
      <div class="row">
         <span class="key" data-type="function">半/全</span>
         <span class="key" data-type="number">1</span>
         <span class="key" data-type="number">2</span>
         <span class="key" data-type="number">3</span>
         <span class="key" data-type="number">4</span>
         <span class="key" data-type="number">5</span>
         <span class="key" data-type="number">6</span>
         <span class="key" data-type="number">7</span>
         <span class="key" data-type="number">8</span>
         <span class="key" data-type="number">9</span>
         <span class="key" data-type="number">0</span>
         <span class="key" data-type="punct">-</span>
         <span class="key" data-type="punct">^</span>
         <span class="key" data-type="punct">¥</span>
         <span class="key" data-type="function">BS</span>
      </div>
      <div class="row">
         <span class="key tab" data-type="function">Tab</span>
         <span class="key" data-type="alpha">Ｑ</span>
         <span class="key" data-type="alpha">Ｗ</span>
         <span class="key" data-type="alpha">Ｅ</span>
         <span class="key" data-type="alpha">Ｒ</span>
         <span class="key" data-type="alpha">Ｔ</span>
         <span class="key" data-type="alpha">Ｙ</span>
         <span class="key" data-type="alpha">Ｕ</span>
         <span class="key" data-type="alpha">Ｉ</span>
         <span class="key" data-type="alpha">Ｏ</span>
         <span class="key" data-type="alpha">Ｐ</span>
         <span class="key" data-type="punct">@</span>
         <span class="key" data-type="punct">[</span>
         <span class="key upper-enter" data-type="function">Enter</span>
      </div>
      <div class="row">
         <span class="key caps" data-type="function">英数</span>
         <span class="key" data-type="alpha">Ａ</span>
         <span class="key" data-type="alpha">Ｓ</span>
         <span class="key" data-type="alpha">Ｄ</span>
         <span class="key" data-type="alpha">Ｆ</span>
         <span class="key" data-type="alpha">Ｇ</span>
         <span class="key" data-type="alpha">Ｈ</span>
         <span class="key" data-type="alpha">Ｊ</span>
         <span class="key" data-type="alpha">Ｋ</span>
         <span class="key" data-type="alpha">Ｌ</span>
         <span class="key" data-type="punct">;</span>
         <span class="key" data-type="punct">:</span>
         <span class="key" data-type="punct">]</span>
         <span class="key lower-enter" data-type="function">↲</span>
      </div>
      <div class="row">
         <span class="key left-shift" data-type="function">Shift</span>
         <span class="key" data-type="alpha">Ｚ</span>
         <span class="key" data-type="alpha">Ｘ</span>
         <span class="key" data-type="alpha">Ｃ</span>
         <span class="key" data-type="alpha">Ｖ</span>
         <span class="key" data-type="alpha">Ｂ</span>
         <span class="key" data-type="alpha">Ｎ</span>
         <span class="key" data-type="alpha">Ｍ</span>
         <span class="key" data-type="punct">,</span>
         <span class="key" data-type="punct">.</span>
         <span class="key" data-type="punct">/</span>
         <span class="key" data-type="duplicate-punct">\</span>
         <span class="key right-shift" data-type="function">Shift</span>
      </div>
      <div class="row">
         <span class="key ctrl" data-type="function">Ctrl</span>
         <span class="key win" data-type="function">Win</span>
         <span class="key alt" data-type="function">Alt</span>
         <span class="key muhenkan" data-type="function">無変換</span>
         <span class="key space" data-type="function">Space</span>
         <span class="key henkan" data-type="function">変換</span>
         <span class="key katakana" data-type="function">
            <span class="shift-symbol">カタカナ</span>
            <span class="base-symbol">ひらがな</span>
         </span>
         <span class="key alt" data-type="function">Alt</span>
         <span class="key app" data-type="function">App</span>
         <span class="key ctrl" data-type="function">Ctrl</span>
      </div>
   </div>

   <div id="us-keyboard-guide" class="keyboard-guide">
      <div class="row">
         <span class="key" data-type="punct">`</span>
         <span class="key" data-type="number">1</span>
         <span class="key" data-type="number">2</span>
         <span class="key" data-type="number">3</span>
         <span class="key" data-type="number">4</span>
         <span class="key" data-type="number">5</span>
         <span class="key" data-type="number">6</span>
         <span class="key" data-type="number">7</span>
         <span class="key" data-type="number">8</span>
         <span class="key" data-type="number">9</span>
         <span class="key" data-type="number">0</span>
         <span class="key" data-type="punct">-</span>
         <span class="key" data-type="punct">=</span>
         <span class="key backspace" data-type="function">Backspace</span>
      </div>
      <div class="row">
         <span class="key tab" data-type="function">Tab</span>
         <span class="key" data-type="alpha">Ｑ</span>
         <span class="key" data-type="alpha">Ｗ</span>
         <span class="key" data-type="alpha">Ｅ</span>
         <span class="key" data-type="alpha">Ｒ</span>
         <span class="key" data-type="alpha">Ｔ</span>
         <span class="key" data-type="alpha">Ｙ</span>
         <span class="key" data-type="alpha">Ｕ</span>
         <span class="key" data-type="alpha">Ｉ</span>
         <span class="key" data-type="alpha">Ｏ</span>
         <span class="key" data-type="alpha">Ｐ</span>
         <span class="key" data-type="punct">[</span>
         <span class="key" data-type="punct">]</span>
         <span class="key backslash" data-type="punct">¥</span>
      </div>
      <div class="row">
         <span class="key caps" data-type="function">Caps Lock</span>
         <span class="key" data-type="alpha">Ａ</span>
         <span class="key" data-type="alpha">Ｓ</span>
         <span class="key" data-type="alpha">Ｄ</span>
         <span class="key" data-type="alpha">Ｆ</span>
         <span class="key" data-type="alpha">Ｇ</span>
         <span class="key" data-type="alpha">Ｈ</span>
         <span class="key" data-type="alpha">Ｊ</span>
         <span class="key" data-type="alpha">Ｋ</span>
         <span class="key" data-type="alpha">Ｌ</span>
         <span class="key" data-type="punct">;</span>
         <span class="key" data-type="punct">'</span>
         <span class="key enter" data-type="function">Enter</span>
      </div>
      <div class="row">
         <span class="key left-shift" data-type="function">Shift</span>
         <span class="key" data-type="alpha">Ｚ</span>
         <span class="key" data-type="alpha">Ｘ</span>
         <span class="key" data-type="alpha">Ｃ</span>
         <span class="key" data-type="alpha">Ｖ</span>
         <span class="key" data-type="alpha">Ｂ</span>
         <span class="key" data-type="alpha">Ｎ</span>
         <span class="key" data-type="alpha">Ｍ</span>
         <span class="key" data-type="punct">,</span>
         <span class="key" data-type="punct">.</span>
         <span class="key" data-type="punct">/</span>
         <span class="key right-shift" data-type="function">Shift</span>
      </div>
      <div class="row">
         <span class="key ctrl" data-type="function">Ctrl</span>
         <span class="key win" data-type="function">Win</span>
         <span class="key alt" data-type="function">Alt</span>
         <span class="key space" data-type="function">Space</span>
         <span class="key alt" data-type="function">Alt</span>
         <span class="key win" data-type="function">Win</span>
         <span class="key app" data-type="function">App</span>
         <span class="key ctrl" data-type="function">Ctrl</span>
      </div>
   </div>

   <div id="result">
      <div id="result-content"></div>
      <div id="detail-toggle">
         <button id="btn-graph" class="toggle-btn active">グラフ表示 (G)</button>
         <button id="btn-table" class="toggle-btn">ログ表示 (D)</button>
         <button id="btn-stats" class="toggle-btn">統計表示 (S)</button>
         <button id="btn-ranking" class="toggle-btn">ランキング (R)</button>
      </div>
      <div id="detail-container">
         <div id="detail-graph">
            <canvas id="graph-canvas" height="196"></canvas>
         </div>
         <div id="detail-table-container"></div>
         <div id="detail-stats" style="display: none;">
            <div id="detail-stats-content" style="width: fit-content; margin: auto auto;"></div>
         </div>
         <div id="detail-ranking" style="display: none;">
            <div id="ranking-content"></div>
         </div>
      </div>
   </div>

   <script>
      class MersenneTwister {
         constructor(seed = Date.now()) {
            this.N = 624;
            this.M = 397;
            this.MATRIX_A = 0x9908b0df;
            this.UPPER_MASK = 0x80000000;
            this.LOWER_MASK = 0x7fffffff;
            this.mt = new Array(this.N);
            this.mti = this.N + 1;
            this.init_genrand(seed >>> 0);
         }
         init_genrand(s) {
            this.mt[0] = s >>> 0;
            for (this.mti = 1; this.mti < this.N; this.mti++) {
               this.mt[this.mti] = (1812433253 * (this.mt[this.mti-1] ^ (this.mt[this.mti-1] >>> 30)) + this.mti) >>> 0;
            }
         }
         genrand_int32() {
            let y;
            const mag01 = [0x0, this.MATRIX_A];
            if (this.mti >= this.N) {
               let kk;
               if (this.mti === this.N + 1) this.init_genrand(5489);
               for (kk = 0; kk < this.N - this.M; kk++) {
                  y = (this.mt[kk] & this.UPPER_MASK) | (this.mt[kk+1] & this.LOWER_MASK);
                  this.mt[kk] = this.mt[kk + this.M] ^ (y >>> 1) ^ mag01[y & 0x1];
               }
               for (; kk < this.N - 1; kk++) {
                  y = (this.mt[kk] & this.UPPER_MASK) | (this.mt[kk+1] & this.LOWER_MASK);
                  this.mt[kk] = this.mt[kk + (this.M - this.N)] ^ (y >>> 1) ^ mag01[y & 0x1];
               }
               y = (this.mt[this.N-1] & this.UPPER_MASK) | (this.mt[0] & this.LOWER_MASK);
               this.mt[this.N-1] = this.mt[this.M-1] ^ (y >>> 1) ^ mag01[y & 0x1];
               this.mti = 0;
            }
            y = this.mt[this.mti++];
            y ^= (y >>> 11);
            y ^= (y << 7) & 0x9d2c5680;
            y ^= (y << 15) & 0xefc60000;
            y ^= (y >>> 18);
            return y >>> 0;
         }
         random() {
            return this.genrand_int32() * (1.0 / 4294967296.0);
         }
      }

      const shiftPairs = {
         JIS: {
            '1': '!',
            '2': '"',
            '3': '#',
            '4': '$',
            '5': '%',
            '6': '&',
            '7': "'",
            '8': '(',
            '9': ')',
            '-': '=',
            '^': '~',
            '@': '`',
            ';': '+',
            ':': '*',
            '[': '{',
            ']': '}',
            '\u00A5': '|',
            '\\': '_',
            ',': '<',
            '.': '>',
            '/': '?'
         },
         US: {
            '`': '~',
            '1': '!',
            '2': '@',
            '3': '#',
            '4': '$',
            '5': '%',
            '6': '^',
            '7': '&',
            '8': '*',
            '9': '(',
            '0': ')',
            '-': '_',
            '=': '+',
            '[': '{',
            ']': '}',
            '\u00A5': '|',
            ';': ':',
            "'": '"',
            ',': '<',
            '.': '>',
            '/': '?'
         }
      };

      function getShiftMap() {
         const pairs = shiftPairs[selectedLayout];
         const map = {};
         for (const [base, shifted] of Object.entries(pairs)) {
            map[shifted] = base;
         }
         return map;
      }

      function getReverseShiftMap() {
         return shiftPairs[selectedLayout];
      }

      function isShiftRequired(char) {
         return char in getShiftMap();
      }

      function getBaseKeyForShift(char) {
         return getShiftMap()[char] || char;
      }

      function getShiftCharFromBase(base) {
         return getReverseShiftMap()[base] || base;
      }

      function toFullWidthAlpha(char) {
         if (char >= 'A' && char <= 'Z') {
            return String.fromCharCode(char.charCodeAt(0) + 0xFEE0);
         }
         return char;
      }

      function createDetailTable() {
         const table = document.createElement('table');
         table.id = 'detail-table';
         const thead = table.createTHead();
         const headerRow = thead.insertRow();
         ['No.', '文字', '時間（秒）', 'ランク', 'スコア'].forEach(text => {
            const th = document.createElement('th');
            th.textContent = text;
            headerRow.appendChild(th);
         });
         const tbody = table.createTBody();
         inputLog.forEach((entry, idx) => {
            const row = tbody.insertRow();
            row.className = entry.type;
            if (entry.type === 'correct') {
               row.style.color = getGreenColor(entry.rank);
            } else {
               row.style.color = '#e74c3c';
            }
            const numStr = (idx + 1).toString().padStart(2, '0');
            [numStr, entry.char, entry.time, entry.rank, entry.point].forEach(text => {
               const td = row.insertCell();
               td.textContent = text;
            });
         });
         return table;
      }

      function createStatsDisplay() {
         const rankCount = { S:0, A:0, B:0, C:0, D:0, E:0, F:0 };
         const charStats = {};

         let totalInputs = 0;
         let bestTime = Infinity;
         let bestChar = '';
         let worstTime = 0;
         let worstChar = '';

         inputLog.forEach(entry => {
            totalInputs++;
            const time = parseFloat(entry.time);

            if (entry.type === 'correct') {
               rankCount[entry.rank]++;
            }

            if (!charStats[entry.char]) {
               charStats[entry.char] = { totalTime: 0, count: 0 };
            }
            charStats[entry.char].totalTime += time;
            charStats[entry.char].count++;

            if (time < bestTime) {
               bestTime = time;
               bestChar = entry.char;
            }
            if (time > worstTime) {
               worstTime = time;
               worstChar = entry.char;
            }
         });

         const accuracy = totalInputs > 0 ? (correctCount / totalInputs * 100).toFixed(1) : 0;
         const missRate = totalInputs > 0 ? (missCount / totalInputs * 100).toFixed(1) : 0;

         let html = '';

         html += '<div class="stats-table-wrapper">';
         html += '<div style="font-weight:bold; text-align:center; margin-bottom:15px;">全体統計</div>';
         html += '<table>';
         html += '<tr><th>総入力回数</th><td>' + totalInputs + ' 回</td></tr>';
         html += '<tr><th>正解率</th><td>' + accuracy + ' ％</td></tr>';
         html += '<tr><th>ミス率</th><td>' + missRate + ' ％</td></tr>';
         html += '<tr><th>最速反応時間</th><td class="flex-time">';
         html += '<span class="time-char">' + bestChar + '</span>';
         html += '<span class="time-arrow">→</span>';
         html += '<span class="time-main">' + bestTime.toFixed(2) + ' 秒</span>';
         html += '</td></tr>';
         html += '<tr><th>最遅反応時間</th><td class="flex-time">';
         html += '<span class="time-char">' + worstChar + '</span>';
         html += '<span class="time-arrow">→</span>';
         html += '<span class="time-main">' + worstTime.toFixed(2) + ' 秒</span>';
         html += '</td></tr>';
         html += '</table>';
         html += '</div>';

         html += '<div class="stats-table-wrapper">';
         html += '<div style="font-weight:bold; text-align:center; margin-bottom:15px;">打鍵ランク別入力回数</div>';
         html += '<table id="rank-table">';
         ['S','A','B','C','D','E','F'].forEach(r => {
            const color = getGreenColor(r);
            html += '<tr><th style="color:' + color + ';">' + r + 'ランク</th><td style="text-align: right;">' + rankCount[r] + ' 回</td></tr>';
         });
         html += '<tr><th style="color:#e74c3c;">ミス</th><td style="text-align: right;">' + missCount + ' 回</td></tr>';
         html += '</table>';
         html += '</div>';

         html += '<div class="stats-table-wrapper">';
         html += '<div style="font-weight:bold; text-align:center; margin-bottom:15px;">文字別平均反応時間</div>';
         html += '<table>';
         html += '<tr><th>文字</th><th>平均時間</th><th>入力回数</th></tr>';
         const sortedChars = Object.keys(charStats)
            .sort((a,b) => charStats[a].totalTime / charStats[a].count - charStats[b].totalTime / charStats[b].count);
         sortedChars.forEach(ch => {
            const avg = (charStats[ch].totalTime / charStats[ch].count).toFixed(2);
            const count = charStats[ch].count;
            html += '<tr><td>' + ch + '</td><td>' + avg + ' 秒</td><td>' + count + ' 回</td></tr>';
         });
         html += '</table>';
         html += '</div>';

         document.getElementById('detail-stats-content').innerHTML = html;
         alignRankTableColumns();
      }

      function alignRankTableColumns() {
         const table = document.getElementById('rank-table');
         if (!table) return;

         const rows = table.querySelectorAll('tr');
         if (rows.length === 0) return;

         let maxLeftWidth = 0;
         let maxRightWidth = 0;

         rows.forEach(row => {
            const th = row.querySelector('th');
            const td = row.querySelector('td');
            if (th) maxLeftWidth = Math.max(maxLeftWidth, th.offsetWidth);
            if (td) maxRightWidth = Math.max(maxRightWidth, td.offsetWidth);
         });

         rows.forEach(row => {
            const th = row.querySelector('th');
            const td = row.querySelector('td');
            if (th) {
               th.style.width = maxLeftWidth + 'px';
               th.style.minWidth = maxLeftWidth + 'px';
            }
            if (td) {
               td.style.width = maxRightWidth + 'px';
               td.style.minWidth = maxRightWidth + 'px';
            }
         });

         table.style.tableLayout = 'fixed';
         table.style.width = 'fit-content';
      }

      function resetDetailContainerWidth() {
          const detailGraph = document.getElementById('detail-graph');
          const detailContainer = document.getElementById('detail-container');
          if (detailGraph) {
              detailGraph.style.width = '';
              detailGraph.style.maxWidth = '';
              detailGraph.style.margin = '';
          }
          if (detailContainer) {
              detailContainer.style.width = '';
              detailContainer.style.maxWidth = '';
              detailContainer.style.margin = '';
          }
      }


      function drawVerticalBarGraph() {
         const canvas = document.getElementById('graph-canvas');
         if (!canvas) return;
         const ctx = canvas.getContext('2d');

         const displayHeight = 192;

         const barWidth = 20;
         const padding = 5;
         const leftMargin = 60;

         const rightMargin = barWidth + padding * 2;

         const labelBottomMargin = 40;

         const totalBarsWidth = inputLog.length * barWidth;
         const totalPaddingCount = inputLog.length;
         const totalPaddingWidth = totalPaddingCount * padding;

         const barsStartX = leftMargin + padding;
         const barsEndX = barsStartX + totalBarsWidth + (inputLog.length > 0 ? (inputLog.length - 1) * padding : 0);
         const axisEndX = barsEndX + padding * 2;

         const calculatedDisplayWidth = leftMargin + totalPaddingWidth + totalBarsWidth + rightMargin;

         canvas.width = calculatedDisplayWidth;
         canvas.height = displayHeight;
         canvas.style.width = calculatedDisplayWidth + 'px';
         canvas.style.height = displayHeight + 'px';
         canvas.style.margin = '0 auto';

         const height = displayHeight;
         const graphHeight = height - labelBottomMargin;

         let rawMaxTime = Math.max(...inputLog.map(entry => parseFloat(entry.time)), 0.1);
         let tickInterval = Math.ceil((rawMaxTime / 4) * 20) / 20;
         let ceiledMax = Math.ceil(rawMaxTime / tickInterval) * tickInterval;
         let maxTime = ceiledMax + (tickInterval / 2);

         ctx.clearRect(0, 0, calculatedDisplayWidth, displayHeight);

         ctx.strokeStyle = '#ccc';
         ctx.lineWidth = 1;
         ctx.beginPath();
         ctx.moveTo(leftMargin, 0);
         ctx.lineTo(leftMargin, height - labelBottomMargin);
         ctx.lineTo(axisEndX, height - labelBottomMargin);
         ctx.stroke();

         const tickCount = 4;
         for (let i = 0; i <= tickCount; i++) {
            const timeVal = i * tickInterval;
            const y = height - labelBottomMargin - (timeVal / maxTime) * graphHeight;
            ctx.fillStyle = '#666';
            ctx.font = '12px "JetBrains Mono", "Noto Sans JP", sans-serif';
            ctx.textAlign = 'right';
            ctx.fillText(timeVal.toFixed(2) + 's', leftMargin - 5, y + 4);

            ctx.strokeStyle = '#eee';
            ctx.beginPath();
            ctx.moveTo(leftMargin, y);
            ctx.lineTo(axisEndX, y);
            ctx.stroke();
         }

         inputLog.forEach((entry, idx) => {
            const x = barsStartX + idx * (barWidth + padding);
            const barHeight = (parseFloat(entry.time) / maxTime) * graphHeight;

            if (entry.type === 'correct') {
               ctx.fillStyle = getGreenColor(entry.rank);
            } else {
               ctx.fillStyle = '#e74c3c';
            }
            ctx.fillRect(x, height - labelBottomMargin - barHeight, barWidth, barHeight);

            ctx.fillStyle = '#333';
            ctx.font = '14px "JetBrains Mono", "Noto Sans JP", sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(entry.char, x + barWidth / 2, height - 25);
         });
      }

      let currentDetailMode = 'graph';

      function updateActiveButtons() {
         document.getElementById('btn-graph').classList.toggle('active', currentDetailMode === 'graph');
         document.getElementById('btn-table').classList.toggle('active', currentDetailMode === 'table');
         document.getElementById('btn-stats').classList.toggle('active', currentDetailMode === 'stats');
         document.getElementById('btn-ranking').classList.toggle('active', currentDetailMode === 'ranking');
      }

      function showStats() {
         document.getElementById('detail-graph').style.display = 'none';
         document.getElementById('detail-table-container').style.display = 'none';
         document.getElementById('detail-stats').style.display = 'block';
         document.getElementById('detail-ranking').style.display = 'none';
         createStatsDisplay();
         resetDetailContainerWidth();
         currentDetailMode = 'stats';
         updateActiveButtons();
         updateFooterVisibility();
      }

      function showTable() {
         document.getElementById('detail-graph').style.display = 'none';
         document.getElementById('detail-table-container').style.display = 'block';
         document.getElementById('detail-stats').style.display = 'none';
         document.getElementById('detail-ranking').style.display = 'none';
         resetDetailContainerWidth();
         currentDetailMode = 'table';
         updateActiveButtons();
         updateFooterVisibility();
      }

      function showGraph() {
         document.getElementById('detail-graph').style.display = 'block';
         document.getElementById('detail-table-container').style.display = 'none';
         document.getElementById('detail-stats').style.display = 'none';
         document.getElementById('detail-ranking').style.display = 'none';
         drawVerticalBarGraph();
         currentDetailMode = 'graph';
         updateActiveButtons();
         updateFooterVisibility();
      }

      function showRanking() {
         document.getElementById('detail-graph').style.display = 'none';
         document.getElementById('detail-table-container').style.display = 'none';
         document.getElementById('detail-stats').style.display = 'none';
         document.getElementById('detail-ranking').style.display = 'block';

         const rankingContent = document.getElementById('ranking-content');
         if (rankingContent.innerHTML === '' || rankingContent.innerHTML.includes('読み込み中')) {
            rankingContent.innerHTML = '<p>読み込み中...</p>';

            (async () => {
               const allScores = await loadRanking();

               const currentModePrefix = `${selectedTime}秒 ${selectedDifficulty}`;
               const filteredScores = allScores.filter(s => s.mode && s.mode.startsWith(currentModePrefix));

               const top10 = filteredScores
                  .sort((a, b) => b.score - a.score)
                  .slice(0, 10);

               let html = `<h2>ランキング（${selectedTime}秒 ${selectedDifficulty} 上位10位）</h2>`;
               html += '<table style="width: fit-content; margin: 20px auto; border-collapse: collapse; font-size: 18px;">';
               html += '<thead>';
               html += '<tr style="background-color: #f2f2f2;">';
               html += '<th style="padding: 10px 20px; text-align: center;">順位</th>';
               html += '<th style="padding: 10px 20px; text-align: left;">名前</th>';
               html += '<th style="padding: 10px 20px; text-align: right;">スコア</th>';
               html += '<th style="padding: 10px 20px; text-align: center;">ランク</th>';
               html += '<th style="padding: 10px 20px; text-align: center;">レイアウト</th>';
               html += '<th style="padding: 10px 20px; text-align: center;">登録日</th>';
               html += '</tr>';
               html += '</thead>';
               html += '<tbody>';

               if (top10.length === 0) {
                  html += '<tr><td colspan="6" style="text-align: center; padding: 20px; color: #666;">まだ登録がありません</td></tr>';
               } else {
                  top10.forEach((s, index) => {
                     const layout = s.mode.split(' ').pop();
                     const rankColor = getGreenColor(s.rank || 'F');
                     const registerDate = new Date(s.timestamp).toLocaleDateString('ja-JP');
                     html += '<tr>';
                     html += `<td style="padding: 10px 20px; text-align: center;">${index + 1}位</td>`;
                     html += `<td style="padding: 10px 20px; text-align: left;">${s.name}</td>`;
                     html += `<td style="padding: 10px 20px; text-align: right;">${s.score}点</td>`;
                     html += `<td style="padding: 10px 20px; text-align: center; color: ${rankColor}; font-weight: bold;">${s.rank || '-'}</td>`;
                     html += `<td style="padding: 10px 20px; text-align: center;">${layout}</td>`;
                     html += `<td style="padding: 10px 20px; text-align: center;">${registerDate}</td>`;
                     html += '</tr>';
                  });
               }

               html += '</tbody>';
               html += '</table>';

               rankingContent.innerHTML = html;
            })();
         }

         resetDetailContainerWidth();
         currentDetailMode = 'ranking';
         updateActiveButtons();
         updateFooterVisibility();
      }

      const mt = new MersenneTwister();
      const targetEl = document.getElementById('target');
      const messageEl = document.getElementById('message');
      const uiGuide = document.getElementById('ui-guide');
      const modeSelectArea = document.getElementById('mode-select');
      const statsEl = document.getElementById('stats');
      const timerDisplay = document.getElementById('timer');
      const correctSpan = document.getElementById('correct');
      const missSpan = document.getElementById('miss');
      const scoreSpan = document.getElementById('score');
      const resultEl = document.getElementById('result');
      const resultContent = document.getElementById('result-content');
      const usKeyboardGuide = document.getElementById('us-keyboard-guide');
      const jisKeyboardGuide = document.getElementById('jis-keyboard-guide');
      let currentKeyboardGuide = usKeyboardGuide;
      let currentChar = '';
      let correctCount = 0;
      let missCount = 0;
      let score = 0;
      let timeLeft = 60;
      let selectedTime = 60;
      let selectedDifficulty = 'Normal';
      let selectedLayout = 'US';
      let timerId = null;
      let countdownInterval = null;
      let gameState = 'ready';
      let charStartTime = null;
      let isInputLocked = false;
      let totalReactionTime = 0;
      let inputLog = [];
      let revealTimer = null;
      let currentGroupIndex = 0;
      let currentItemIndex = [1, 1, 0];
      const timeOptions = ['15秒', '30秒', '60秒'];
      const difficultyOptions = ['Easy', 'Normal', 'Hard'];
      const layoutOptions = ['JIS', 'US'];
      const modeGroups = document.querySelectorAll('.mode-group');
      const selectedItems = document.querySelectorAll('.selected-item');
      let charSet = '';

      function normalizeYen(char) {
         return char === '￥' ? '\u00A5' : char;
      }

      function updateCharSet(difficulty) {
         const alphaKeys = currentKeyboardGuide.querySelectorAll('.key[data-type="alpha"]');
         const numberKeys = currentKeyboardGuide.querySelectorAll('.key[data-type="number"]');
         const punctBaseKeys = currentKeyboardGuide.querySelectorAll('.key[data-type="punct"]');

         const alphas = Array.from(alphaKeys).map(k => k.dataset.originalText || k.textContent.trim()).join('');
         const numbers = Array.from(numberKeys).map(k => k.dataset.originalText || k.textContent.trim()).join('');
         const basePunct = Array.from(punctBaseKeys).map(k => normalizeYen(k.dataset.originalText || k.textContent.trim())).join('');

         if (difficulty === 'Easy') {
            charSet = alphas;
         } else if (difficulty === 'Normal') {
            charSet = alphas + numbers + basePunct;
         } else if (difficulty === 'Hard') {
            const punctSet = new Set(basePunct);
            for (const shifted of Object.values(shiftPairs[selectedLayout])) {
               punctSet.add(shifted);
            }
            punctSet.add('\u00A5');
            const allPunct = [...punctSet].join('');
            charSet = alphas + numbers + allPunct;
         }

         updateKeyboardVisibility();
      }

      function updateSelection() {
         const oldGuide = currentKeyboardGuide;

         if (!usKeyboardGuide.dataset.initialized) {
            document.querySelectorAll('#us-keyboard-guide .key, #jis-keyboard-guide .key').forEach(key => {
               const text = key.textContent.trim();
               key.dataset.originalText = normalizeYen(text);
            });
            usKeyboardGuide.dataset.initialized = 'true';
            jisKeyboardGuide.dataset.initialized = 'true';
         }
         modeGroups.forEach((g, i) => {
            g.classList.toggle('focused', i === currentGroupIndex);
         });
         const timeIndex = Math.max(0, Math.min(timeOptions.length - 1, currentItemIndex[0]));
         const diffIndex = Math.max(0, Math.min(difficultyOptions.length - 1, currentItemIndex[1]));
         const layoutIndex = Math.max(0, Math.min(layoutOptions.length - 1, currentItemIndex[2]));
         selectedItems[0].textContent = timeOptions[timeIndex];
         selectedItems[1].textContent = difficultyOptions[diffIndex];
         selectedItems[2].textContent = layoutOptions[layoutIndex];
         const selectedTimeText = timeOptions[timeIndex];
         const newTime = parseInt(selectedTimeText.replace('秒', '')) || 60;
         timerDisplay.textContent = newTime;
         selectedTime = newTime;
         timeLeft = newTime;

         const newDifficulty = difficultyOptions[diffIndex];
         selectedDifficulty = newDifficulty;

         selectedLayout = layoutOptions[layoutIndex];

         usKeyboardGuide.style.display = selectedLayout === 'US' ? 'flex' : 'none';
         jisKeyboardGuide.style.display = selectedLayout === 'JIS' ? 'flex' : 'none';
         currentKeyboardGuide = selectedLayout === 'US' ? usKeyboardGuide : jisKeyboardGuide;

         if (oldGuide && oldGuide !== currentKeyboardGuide) {
            oldGuide.style.backgroundColor = '';
            oldGuide.style.color = '';
         }

         updateCharSet(newDifficulty);
         updateKeyboardVisibility();
      }

      function findKeyByBaseChar(baseChar) {
         return Array.from(currentKeyboardGuide.querySelectorAll('.key')).find(key => {
            return (key.dataset.originalText || key.textContent.trim()) === baseChar;
         });
      }

      function updateKeyboardVisibility() {
         const keys = currentKeyboardGuide.querySelectorAll('.key');
         keys.forEach(key => {
            const originalText = key.dataset.originalText || key.textContent.trim();
            key.innerHTML = `<span class="base-symbol">${originalText}</span>`;
            key.dataset.baseChar = originalText;
            key.dataset.shiftChar = '';
            key.classList.add('hidden');
         });

         currentKeyboardGuide.querySelectorAll('.key[data-type="function"]').forEach(key => {
            key.classList.remove('hidden');
         });

         for (const char of charSet) {
            if (isShiftRequired(char)) {
               const baseChar = getBaseKeyForShift(char);
               const key = findKeyByBaseChar(baseChar);
               if (key) {
                  const shiftChar = getShiftCharFromBase(baseChar);
                  key.innerHTML = `
                     <span class="shift-symbol">${shiftChar}</span>
                     <span class="base-symbol">${key.dataset.originalText}</span>
                  `;
                  key.dataset.shiftChar = shiftChar;
                  key.classList.remove('hidden');
               }
            } else {
               const key = findKeyByBaseChar(char);
               if (key) {
                  key.classList.remove('hidden');
               }
            }
         }

         if (selectedLayout === 'JIS') {
            const dupKey = currentKeyboardGuide.querySelector('.key[data-type="duplicate-punct"]');
            if (dupKey) {
               const baseText = dupKey.dataset.originalText || '\\';
               if (selectedDifficulty === 'Normal') {
                  dupKey.classList.remove('hidden');
                  dupKey.innerHTML = `<span class="base-symbol">${baseText}</span>`;
                  const baseSymbol = dupKey.querySelector('.base-symbol');
                  if (baseSymbol) {
                     baseSymbol.style.color = '#aaa';
                  }
               } else if (selectedDifficulty === 'Hard') {
                  const baseSymbol = dupKey.querySelector('.base-symbol');
                  if (baseSymbol) {
                     baseSymbol.style.color = '#aaa';
                  }
               }
            }
         }
      }

      function highlightCorrect(char, rank = 'C') {
         clearHighlights();
         let targetColor = getGreenColor(rank);

         let highlightChar = char;
         if (isShiftRequired(char)) {
            highlightChar = getBaseKeyForShift(char);
         }

         if (isShiftRequired(char)) {
            currentKeyboardGuide.querySelectorAll('.left-shift, .right-shift').forEach(key => {
               key.classList.add('correct-key');
               key.style.backgroundColor = targetColor;
               key.style.color = 'white';
            });
         }

         const key = findKeyByBaseChar(highlightChar);
         if (key) {
            key.classList.add('correct-key');
            key.style.backgroundColor = targetColor;
            key.style.color = 'white';
         }
      }

   function highlightMiss(pressedChar, correctChar, isShiftPressed = false) {
      clearHighlights();
      const missColor = '#e74c3c';
      const hintColor = '#FF8888';
      const partialCorrectColor = '#00BB00';

      let pressedHighlightChar = pressedChar;
      if (isShiftRequired(pressedChar)) {
         pressedHighlightChar = getBaseKeyForShift(pressedChar);
      }

      let correctHighlightChar = correctChar;
      if (isShiftRequired(correctChar)) {
         correctHighlightChar = getBaseKeyForShift(correctChar);
      }

      const baseKeyCorrect = getBaseKeyForShift(pressedChar) === getBaseKeyForShift(correctChar);
      const shiftCorrect = isShiftRequired(correctChar) === isShiftPressed;

      const needShiftHighlight = (isShiftPressed !== isShiftRequired(correctChar)) || (isShiftPressed && isShiftRequired(correctChar) && !baseKeyCorrect);

      if (needShiftHighlight) {
         let shiftBgColor;
         if (isShiftPressed && !isShiftRequired(correctChar)) {
            shiftBgColor = missColor;
         } else if (!isShiftPressed && isShiftRequired(correctChar)) {
            shiftBgColor = hintColor;
         } else {
            shiftBgColor = missColor;
         }

         currentKeyboardGuide.querySelectorAll('.left-shift, .right-shift').forEach(key => {
            if (shiftCorrect && !baseKeyCorrect) {
               key.classList.add('partial-correct');
            } else {
               key.style.backgroundColor = shiftBgColor;
               key.style.color = 'white';
               key.classList.add(shiftBgColor === missColor ? 'miss-key' : 'hint-key');
            }
         });
      }

      const pressedKey = findKeyByBaseChar(pressedHighlightChar);
      if (pressedKey && !baseKeyCorrect) {
         pressedKey.classList.add('miss-key');
         pressedKey.style.backgroundColor = missColor;
         pressedKey.style.color = 'white';
      }

      const correctKey = findKeyByBaseChar(correctHighlightChar);
         if (correctKey) {
            if (baseKeyCorrect) {
               correctKey.classList.add('partial-correct');
            } else {
               correctKey.classList.add('hint-key');
               correctKey.style.backgroundColor = hintColor;
               correctKey.style.color = 'white';
            }
         }
      }

      function highlightHint(char) {
         clearHighlights();
         const hintColor = '#FF8888';

         let highlightChar = char;
         if (isShiftRequired(char)) {
            highlightChar = getBaseKeyForShift(char);
            currentKeyboardGuide.querySelectorAll('.left-shift, .right-shift').forEach(key => {
               key.classList.add('hint-key');
               key.style.backgroundColor = hintColor;
               key.style.color = 'white';
            });
         }
         const key = findKeyByBaseChar(highlightChar);
         if (key) {
            key.classList.add('hint-key');
            key.style.backgroundColor = hintColor;
            key.style.color = 'white';
         }
      }

      function clearHighlights() {
         currentKeyboardGuide.querySelectorAll('.key').forEach(key => {
            key.classList.remove('correct-key', 'miss-key', 'hint-key', 'partial-correct');
            key.style.backgroundColor = '';
            key.style.color = '';
            key.style.borderColor = '';
            key.style.borderWidth = '';
         });
         updateKeyboardVisibility();
      }

      function clearMenuHoverHighlights() {
         timerDisplay.style.backgroundColor = '';
         timerDisplay.style.color = '';

         if (currentKeyboardGuide) {
            currentKeyboardGuide.querySelectorAll('.key:not([data-type="function"])').forEach(key => {
               key.style.backgroundColor = '';
               key.style.color = '';
            });
         }

         if (currentKeyboardGuide) {
            currentKeyboardGuide.style.backgroundColor = '';
            currentKeyboardGuide.style.color = '';
         }
      }

      function setTargetBox(enabled) {
         if (enabled) {
            targetEl.style.width = '0 180px';
            targetEl.style.backgroundColor = '#ffffff';
         } else {
            targetEl.style.width = '';
            targetEl.style.backgroundColor = '';
         }
      }
      function getRank(reactionTime) {
         if (reactionTime <= 0.25) return 'S';
         else if (reactionTime <= 0.3) return 'A';
         else if (reactionTime <= 0.4) return 'B';
         else if (reactionTime <= 0.5) return 'C';
         else if (reactionTime <= 0.6) return 'D';
         else if (reactionTime <= 1.0) return 'E';
         else return 'F';
      }

      function getPointFromRank(rank) {
         switch (rank) {
            case 'S': return 30;
            case 'A': return 20;
            case 'B': return 15;
            case 'C': return 10;
            case 'D': return 5;
            case 'E': return 1;
            case 'F': return -1;
            default: return 0;
         }
      }

      function getGreenColor(rank) {
         switch (rank) {
            case 'S': return '#FFD700';
            case 'A': return '#00FF00';
            case 'B': return '#00DD00';
            case 'C': return '#00BB00';
            case 'D': return '#009900';
            case 'E': return '#007700';
            case 'F': return '#8B0000';
            default: return '#333';
         }
      }

      function getRankMessage(rank) {
         switch (rank) {
            case 'S': return '前人未踏です';
            case 'A': return '驚異的です';
            case 'B': return '優秀です';
            case 'C': return '合格です';
            case 'D': return '練習が足りません';
            case 'E': return '話になりません';
            case 'F': return '日が暮れてしまいます';
            default: return '';
         }
      }

      function getIdealCorrect(timeLimit, maxReaction) {
         return Math.floor(timeLimit / (0.5 + maxReaction));
      }

      function getOverallRank(actualScore, timeLimit) {
         const idealS = getIdealCorrect(timeLimit, 0.25);
         const idealA = getIdealCorrect(timeLimit, 0.3);
         const idealB = getIdealCorrect(timeLimit, 0.4);
         const idealC = getIdealCorrect(timeLimit, 0.5);
         const idealD = getIdealCorrect(timeLimit, 0.6);
         const sThreshold = idealS * 30;
         const aThreshold = idealA * 20;
         const bThreshold = idealB * 15;
         const cThreshold = idealC * 10;
         const dThreshold = idealD * 5;
         const eThreshold = 0;
         if (actualScore >= sThreshold) return 'S';
         else if (actualScore >= aThreshold) return 'A';
         else if (actualScore >= bThreshold) return 'B';
         else if (actualScore >= cThreshold) return 'C';
         else if (actualScore >= dThreshold) return 'D';
         else if (actualScore >= eThreshold) return 'E';
         else return 'F';
      }

      function showNewChar() {
         if (gameState !== 'playing') return;
         clearHighlights();
         const idx = Math.floor(mt.random() * charSet.length);
         currentChar = charSet[idx];
         targetEl.textContent = currentChar;
         targetEl.style.color = '#333';
         messageEl.textContent = '';
         charStartTime = performance.now();
         isInputLocked = false;
         revealTimer = setTimeout(() => {
            if (gameState !== 'playing') return;
            highlightHint(currentChar);
         }, 1000);
      }

      function startCountdown() {
            gameState = 'countdown';
            updateFooterVisibility();
            setTargetBox(true);
            
            targetEl.textContent = '';
            targetEl.style.color = '#333';

            messageEl.textContent = 'Ready?';
            messageEl.style.color = '#333';

            setTimeout(() => {
                  let count = 3;

                  messageEl.textContent = count;

                  countdownInterval = setInterval(() => {
                        count--;

                        if (count > 0) {
                              messageEl.textContent = count;
                        } else {
                              clearInterval(countdownInterval);

                              gameState = 'playing';
                              updateFooterVisibility();

                              showNewChar();

                              messageEl.textContent = 'Go!';
                              messageEl.style.color = '#333';

                              timeLeft = selectedTime;
                              timerDisplay.textContent = timeLeft;

                              setTimeout(() => {
                                    if (gameState !== 'playing') return;
                                    messageEl.textContent = '';
                                    messageEl.style.color = '#333';
                              }, 1000);

                              startTimer();
                        }
                  }, 1000);
            }, 1000);
      }

      function startTimer() {
         timerId = setInterval(() => {
            timeLeft--;
            timerDisplay.textContent = timeLeft;
            if (timeLeft <= 0) {
               clearInterval(timerId);
               gameState = 'timeup';
               setTargetBox(false);
               targetEl.textContent = '終';
               targetEl.style.color = '#333';
               messageEl.textContent = 'Time Up!';
               setTimeout(() => {
                  endGame();
               }, 1000);
            }
         }, 1000);
      }

      function startGame() {
         selectedTime = parseInt(timeOptions[currentItemIndex[0]].replace('秒', '')) || 60;
         selectedDifficulty = difficultyOptions[currentItemIndex[1]];
         selectedLayout = layoutOptions[currentItemIndex[2]];
         timeLeft = selectedTime;
         timerDisplay.textContent = timeLeft;
         timerDisplay.style.display = 'block';
         updateCharSet(selectedDifficulty);
         correctCount = 0;
         missCount = 0;
         score = 0;
         totalReactionTime = 0;
         inputLog = [];
         correctSpan.textContent = 0;
         missSpan.textContent = 0;
         scoreSpan.textContent = 0;
         timerDisplay.style.display = 'block';
         targetEl.style.display = 'block';
         messageEl.style.height = '60px';
         messageEl.style.margin = '0 0 30px 0';
         clearInterval(timerId);
         clearInterval(countdownInterval);
         timerDisplay.style.color = '#d35400';
         statsEl.style.display = 'flex';
         usKeyboardGuide.style.display = selectedLayout === 'US' ? 'flex' : 'none';
         jisKeyboardGuide.style.display = selectedLayout === 'JIS' ? 'flex' : 'none';
         currentKeyboardGuide = selectedLayout === 'US' ? usKeyboardGuide : jisKeyboardGuide;
         resultEl.style.display = 'none';
         modeSelectArea.style.display = 'none';
         uiGuide.textContent = 'Esc：中断';
         clearHighlights();
         clearMenuHoverHighlights();
         startCountdown();
      }

      async function endGame() {
         clearInterval(timerId);
         clearInterval(countdownInterval);
         gameState = 'ended';
         updateFooterVisibility();
         setTargetBox(false);
         timerDisplay.style.display = 'none';
         targetEl.style.display = 'none';
         messageEl.textContent = '';
         messageEl.style.height = '0';
         messageEl.style.margin = '0';
         statsEl.style.display = 'none';
         usKeyboardGuide.style.display = 'none';
         jisKeyboardGuide.style.display = 'none';
         uiGuide.textContent = 'Enter/Space：リトライ　Esc：トップに戻る　X：結果をツイート';
         modeSelectArea.style.display = 'flex';
         modeGroups.forEach(g => g.classList.remove('focused'));
         document.body.classList.add('result-mode');
         const totalInputs = correctCount + missCount;
         let avgTime = totalInputs > 0 ? totalReactionTime / totalInputs : 0;
         let finalRank = getOverallRank(score, selectedTime);
         let rankMessage = getRankMessage(finalRank);
         let rankColor = getGreenColor(finalRank);

         const tweetText = 
            `閃ｰセンｰ をプレイしました\n` +
            `モード：${selectedTime}秒 ${selectedDifficulty} ${selectedLayout}\n` +
            `総合スコア：${score}点\n` +
            `総合ランク：${finalRank}\n` +
            `「${rankMessage}」\n` +
            `平均反応時間：${avgTime.toFixed(2)}秒\n` +
            `正解：${correctCount}回　ミス：${missCount}回\n` +
            `https://tk-laboratory.github.io/SEN/\n` +
            `#閃ｰセンｰ`;

         window.currentTweetUrl = `https://x.com/intent/tweet?text=${encodeURIComponent(tweetText)}`;
         
         resultEl.style.display = 'block';
         resultContent.innerHTML = `
            <div style="font-size:48px; margin:20px 0;">
               総合スコア <strong style="color:${rankColor};">${score}</strong> 点
            </div>
            <div style="font-size:36px; margin:15px 0;">
               総合ランク <strong style="color:${rankColor};">${finalRank}</strong>
            </div>
            <div style="font-size:32px; margin:10px 0; color:${rankColor}; font-weight: bold;">
               ${rankMessage}
            </div>
            <div style="font-size:28px;">平均反応時間 ${avgTime.toFixed(2)} 秒</div>
            <div style="font-size:28px; margin-top:20px;">
               正解 ${correctCount} 回　ミス ${missCount} 回
            </div>
         `;

         const container = document.getElementById('detail-container');
         const tableContainer = document.getElementById('detail-table-container');
         container.style.display = 'block';
         tableContainer.innerHTML = '';
         tableContainer.appendChild(createDetailTable());
         document.getElementById('detail-toggle').style.display = 'flex';
         showGraph();
         clearHighlights();

         let isNewRecord = false;
         let existingScore = null;

         try {
            const uid = window.firebase.auth.currentUser ? window.firebase.auth.currentUser.uid : 'guest_' + Date.now();
            const sanitizedMode = `${selectedTime}秒 ${selectedDifficulty} ${selectedLayout}`.replace(/[.$#[\]/]/g, '_');
            const sanitizedUid = uid.replace(/[.$#[\]/]/g, '_');
            
            const userRef = window.firebase.ref(window.firebase.db, `scores/${sanitizedMode}/${sanitizedUid}`);

            const snapshot = await window.firebase.get(userRef);
            if (snapshot.exists()) {
               existingScore = snapshot.val().score;
               if (score > existingScore) {
                  isNewRecord = true;
               }
            } else {
               isNewRecord = true;
            }
         } catch (err) {
            console.error("既存スコア取得失敗:", err);
            isNewRecord = true;
         }

         let registeredName = null;

         if (isNewRecord) {
            const promptMessage = existingScore === null 
               ? "新記録樹立！\nランキング登録名（20文字以内・キャンセルで登録なし）"
               : `新記録樹立！（従来:${existingScore}点 → ${score}点）\nランキング登録名（20文字以内・キャンセルで登録なし）`;

            let name = prompt(promptMessage, "Anonymous");
            if (name !== null) {
               name = name.trim();
               if (name === "") name = "Anonymous";
               name = name.substring(0, 20);

               const mode = `${selectedTime}秒 ${selectedDifficulty} ${selectedLayout}`;
               await saveScore(name, score, mode, finalRank);
               registeredName = name;
            }
         }

         document.getElementById('ranking-content').innerHTML = '';
      }

      function resetToInitial() {
         clearInterval(timerId);
         clearInterval(countdownInterval);
         gameState = 'ready';
         updateFooterVisibility();
         setTargetBox(false);
         resultEl.style.display = 'none';
         modeSelectArea.style.display = 'flex';
         statsEl.style.display = 'none';
         timerDisplay.style.display = 'block';
         timerDisplay.style.color = '#d35400';
         timerDisplay.style.margin = '10px 0';
         timerDisplay.textContent = selectedTime;
         timeLeft = selectedTime;
         targetEl.style.display = 'block';
         targetEl.textContent = '閃';
         targetEl.style.color = '#333';
         messageEl.textContent = 'ｰセンｰ';
         messageEl.style.height = '60px';
         messageEl.style.margin = '0 0 30px 0';
         uiGuide.textContent = 'Enter/Space：開始';
         correctSpan.textContent = 0;
         missSpan.textContent = 0;
         scoreSpan.textContent = 0;
         usKeyboardGuide.style.display = selectedLayout === 'US' ? 'flex' : 'none';
         jisKeyboardGuide.style.display = selectedLayout === 'JIS' ? 'flex' : 'none';
         currentKeyboardGuide = selectedLayout === 'US' ? usKeyboardGuide : jisKeyboardGuide;
         clearHighlights();
         document.body.classList.remove('result-mode');
         updateSelection();
      }

      function syncFooterWidth() {
         const footerDiv = document.querySelector('footer > div');
         const policyContent = document.querySelector('.policy-content');
         if (gameState === 'ready') {
            footerDiv.style.width = '596px';
            footerDiv.style.maxWidth = '596px';
            footerDiv.style.minWidth = '596px';
            if (policyContent) {
               policyContent.style.width = '596px';
               policyContent.style.maxWidth = '596px';
               policyContent.style.minWidth = '596px';
            }
         } else if (gameState === 'ended' && currentDetailMode === 'ranking') {
            footerDiv.style.width = '668px';
            footerDiv.style.maxWidth = '668px';
            footerDiv.style.minWidth = '668px';
            if (policyContent) {
               policyContent.style.width = '668px';
               policyContent.style.maxWidth = '668px';
               policyContent.style.minWidth = '668px';
            }
         }
      }

      function updateFooterVisibility() {
         const footer = document.querySelector('footer');
         let showFooter = false;
         if (gameState === 'ready') {
            showFooter = true;
         }
         if (gameState === 'ended' && currentDetailMode === 'ranking') {
            showFooter = true;
         }

         footer.style.display = showFooter ? 'block' : 'none';
         if (showFooter) {
            syncFooterWidth();
         }
      }

      document.querySelectorAll('.dropdown-item').forEach(item => {
         item.addEventListener('click', (e) => {
            if (gameState !== 'ready') return;
            e.stopPropagation();
            const value = item.dataset.value;
            const parentGroup = item.closest('.mode-group');
            const groupId = parentGroup.id;
            let groupIndex = 0;
            if (groupId === 'time-group') groupIndex = 0;
            else if (groupId === 'difficulty-group') groupIndex = 1;
            else if (groupId === 'layout-group') groupIndex = 2;

            const options = groupIndex === 0 ? timeOptions :
                            groupIndex === 1 ? difficultyOptions : layoutOptions;
            const index = options.indexOf(value);
            if (index !== -1) {
               currentItemIndex[groupIndex] = index;
               parentGroup.querySelector('.selected-item').textContent = value;
               updateSelection();

               const targetGroup = (groupIndex === 1) ? document.getElementById('difficulty-group') :
                                   (groupIndex === 2) ? document.getElementById('layout-group') : null;

               if (targetGroup && targetGroup.classList.contains('focused')) {
                    const enterEvent = new MouseEvent('mouseenter', {
                       bubbles: true,
                       cancelable: true,
                       view: window
                   });
                   targetGroup.dispatchEvent(enterEvent);
               }
            }
         });
      });

      modeGroups.forEach((group, index) => {
         group.addEventListener('click', () => {
            if (gameState === 'ready') {
               currentGroupIndex = index;
               updateSelection();

               const enterEvent = new MouseEvent('mouseenter', {
                  bubbles: true,
                  cancelable: true,
                  view: window
               });
               group.dispatchEvent(enterEvent);
            }
         });
      });

      modeGroups.forEach(group => {
         group.addEventListener('mouseenter', () => {
            if (gameState !== 'ready' || !group.classList.contains('focused')) return;

            if (group.id === 'time-group') {
               timerDisplay.style.backgroundColor = '#00DD00';
               timerDisplay.style.color = '#ffffff';
            } else if (group.id === 'difficulty-group') {
               currentKeyboardGuide.querySelectorAll('.key:not([data-type="function"])').forEach(key => {
                  key.style.backgroundColor = '#00DD00';
                  key.style.color = key.classList.contains('hidden') ? '#00DD00' : '#ffffff';
               });
            } else if (group.id === 'layout-group') {
               currentKeyboardGuide.style.backgroundColor = '#00DD00';
               currentKeyboardGuide.style.color = '#ffffff';
            }
         });

         group.addEventListener('mouseleave', () => {
            if (gameState !== 'ready' || !group.classList.contains('focused')) return;
            clearMenuHoverHighlights();
         });
      });

      document.addEventListener('keydown', (e) => {

      if (e.key.toUpperCase() === 'P') {
         if (gameState !== 'playing') {
            const policy = document.querySelector('.policy-content');
               if (policy) {
                  policy.style.display = (policy.style.display === 'none' || policy.style.display === '') ? 'block' : 'none';
                  }
                  return;
               }
            }
            
         if (e.key === 'Escape') {
            if (gameState !== 'ready') {
               resetToInitial();
            }
            return;
         }
         if (gameState === 'ready' || gameState === 'ended') {
            if (e.code === 'Space' || e.key === 'Enter') {
               e.preventDefault();
               startGame();
               return;
            }
         }
         if (gameState === 'ready') {
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
               e.preventDefault();
               currentGroupIndex = e.key === 'ArrowLeft'
                  ? (currentGroupIndex - 1 + modeGroups.length) % modeGroups.length
                  : (currentGroupIndex + 1) % modeGroups.length;
               updateSelection();
               return;
            }
            if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
               e.preventDefault();
               const len = currentGroupIndex === 0 ? timeOptions.length
                  : currentGroupIndex === 1 ? difficultyOptions.length : layoutOptions.length;
               if (e.key === 'ArrowUp') {
                  currentItemIndex[currentGroupIndex] = (currentItemIndex[currentGroupIndex] - 1 + len) % len;
               } else {
                  currentItemIndex[currentGroupIndex] = (currentItemIndex[currentGroupIndex] + 1) % len;
               }
               updateSelection();
               return;
            }
         }
         if (gameState === 'ended') {
            if (e.key.toUpperCase() === 'G') {
               showGraph();
               return;
            }
            if (e.key.toUpperCase() === 'D') {
               showTable();
               return;
            }
            if (e.key.toUpperCase() === 'S') {
               showStats();
               return;
            }
            if (e.key.toUpperCase() === 'R') {
               showRanking();
               return;
            }
            if (e.key.toUpperCase() === 'X') {
               if (window.currentTweetUrl) {
                  window.open(window.currentTweetUrl, '_blank', 'noopener');
               }
               return;
            }
            if (e.key === 'ArrowLeft') {
               if (currentDetailMode === 'graph') {
                  showStats();
               } else if (currentDetailMode === 'table') {
                  showGraph();
               } else if (currentDetailMode === 'stats') {
                  showTable();
               }
               return;
            }
            if (e.key === 'ArrowRight') {
               if (currentDetailMode === 'graph') {
                  showTable();
               } else if (currentDetailMode === 'table') {
                  showStats();
               } else if (currentDetailMode === 'stats') {
                  showGraph();
               }
               return;
            }
         }
         if (gameState !== 'playing') return;

         e.preventDefault();

         if (e.key.length > 1) {
            return;
         }

         let pressedKey = e.key.toUpperCase();

         if (pressedKey === '\\' || pressedKey === '¥' || e.key === '\u00A5') {
            pressedKey = '\u00A5';
         }

         pressedKey = toFullWidthAlpha(pressedKey);

         const isShiftPressed = e.shiftKey;

         if (isInputLocked) return;
         isInputLocked = true;
         if (revealTimer) {
            clearTimeout(revealTimer);
            revealTimer = null;
         }
         let reactionTime = (performance.now() - charStartTime) / 1000;
         if (pressedKey === currentChar) {
            const rank = getRank(reactionTime);
            const point = getPointFromRank(rank);
            score += point;
            correctCount++;
            correctSpan.textContent = correctCount;
            scoreSpan.textContent = score;
            targetEl.style.color = getGreenColor(rank);
            messageEl.textContent = `${rank} (${reactionTime.toFixed(2)}秒 / ${point >= 0 ? '+' : ''}${point}点)`;
            totalReactionTime += reactionTime;
            inputLog.push({
               type: 'correct',
               char: currentChar,
               time: reactionTime.toFixed(2),
               rank: rank,
               point: point >= 0 ? `+${point}` : `${point}`
            });
            highlightCorrect(currentChar, rank);
         } else {
            score -= 10;
            missCount++;
            missSpan.textContent = missCount;
            scoreSpan.textContent = score;
            targetEl.style.color = 'red';
            messageEl.textContent = `ミス... (${reactionTime.toFixed(2)}秒 / -10点)`;
            totalReactionTime += reactionTime;
            inputLog.push({
               type: 'miss',
               char: currentChar,
               time: reactionTime.toFixed(2),
               rank: '-',
               point: '-10'
            });
            highlightMiss(pressedKey, currentChar, e.shiftKey);
         }
         setTimeout(() => {
            showNewChar();
         }, 500);
      });

      document.getElementById('btn-graph').addEventListener('click', showGraph);
      document.getElementById('btn-table').addEventListener('click', showTable);
      document.getElementById('btn-stats').addEventListener('click', showStats);
      document.getElementById('btn-ranking').addEventListener('click', showRanking);
      updateSelection();
   </script>

   <script type="module">
      import { initializeApp } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-app.js";
      import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-auth.js";
      import { getDatabase, ref, set, get, query, orderByChild, limitToFirst } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-database.js";

      const firebaseConfig = {
        apiKey: "AIzaSyAyyyQ0D0Lc2zfIRUm97Ztwz1gfbxeVP50",
        authDomain: "sen-ranking.firebaseapp.com",
        databaseURL: "https://sen-ranking-default-rtdb.asia-southeast1.firebasedatabase.app",
        projectId: "sen-ranking",
        storageBucket: "sen-ranking.firebasestorage.app",
        messagingSenderId: "537304153403",
        appId: "1:537304153403:web:7af22994739095fd02cb1e"
      };

      console.log("Firebase初期化開始");
      const app = initializeApp(firebaseConfig);
      const auth = getAuth(app);
      window.auth = auth;
      const db = getDatabase(app);

      window.firebase = {
         auth: auth,
         db: db,
         ref: ref,
         get: get
      };

      signInAnonymously(auth)
        .then(() => console.log("匿名認証成功"))
        .catch(err => console.error("匿名認証失敗:", err));

      window.saveScore = async function(name, score, mode, rank) {
         try {
            const uid = auth.currentUser ? auth.currentUser.uid : 'guest_' + Date.now();

            const sanitizedMode = mode.replace(/[.$#[\]/]/g, '_');
            const sanitizedUid = uid.replace(/[.$#[\]/]/g, '_');

            const userRef = ref(db, `scores/${sanitizedMode}/${sanitizedUid}`);

            const snapshot = await get(userRef);
            if (snapshot.exists()) {
               const existing = snapshot.val();
               if (score <= existing.score) {
                  console.log("既存スコアの方が高いか同等なので更新せず（自分の記録）");
                  return;
               } else {
                  console.log("最高スコア更新！（自分の記録）");
               }
            }

            await set(userRef, {
               name: name,
               score: score,
               mode: mode,
               rank: rank,
               timestamp: Date.now(),
               uid: uid
            });
            console.log("スコア保存/更新成功:", { name, score, mode, rank });
         } catch (err) {
            console.error("スコア保存失敗:", err);
         }
      };

      window.loadRanking = async function() {
         try {
            const scoresRef = ref(db, 'scores');
            const snapshot = await get(scoresRef);
            if (snapshot.exists()) {
               const data = [];
               snapshot.forEach(modeSnapshot => {
                  modeSnapshot.forEach(userSnapshot => {
                     data.push(userSnapshot.val());
                  });
               });
               console.log("全ランキング取得成功:", data.length + "件");
               return data;
            } else {
               console.log("ランキングデータなし");
               return [];
            }
         } catch (err) {
            console.error("ランキング取得失敗:", err);
            return [];
         }
      };
   </script>
   <footer>
      <div>
         <div style="cursor: pointer; font-size: 16px; text-align: left; color: #666" onclick="this.parentNode.parentNode.querySelector('.policy-content').style.display = (this.parentNode.parentNode.querySelector('.policy-content').style.display === 'none' || this.parentNode.parentNode.querySelector('.policy-content').style.display === '') ? 'block' : 'none';">
            Privacy Policy (P)
         </div>
         <div class="policy-content" style="display: none; margin-top: 20px; text-align: left; color: #666; line-height: 1.6;">
            <p>本ゲーム「閃ｰセンｰ」は、匿名でプレイ可能です。<br>
            ランキング登録時はブラウザ固有の匿名ID（個人を特定できない一時的なID）を使用し、メールアドレスや個人情報は一切収集しません。<br>
            登録データ（表示名・スコア・モード・ランク・登録日時）はランキング表示のみに使用し、第三者に提供することはありません。<br>
            データはFirebase（Google LLC）で管理されており、Googleのプライバシーポリシーが適用されます。<br>
            ブラウザのキャッシュクリア等で匿名IDが変わる場合、過去記録が引き継がれない可能性があります。</p>
            <p>ゲームプレイのスクリーンショット、記録画像、プレイ動画のSNS投稿・アップロード・配信は自由です。</p>
            <p>制作者: TK Lab. (https://x.com/TK_Lab_)<br>
            ご質問・ご要望はXのDMやリプライまでご連絡ください。</p>
         </div>
      </div>
   </footer>
</body>
</html>




